{
  "name": "@ping-me/core",
  "description": "The foundational package for Ping-Me, providing the core functionality to keep your services alive and monitor their health.",
  "version": "1.0.0",
  "author": "Eshank Tyagi",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/mreshank/ping-me",
    "directory": "packages/core"
  },
  "homepage": "https://ping-me.eshank.tech",
  "documentation": "https://ping-me.eshank.tech/docs",
  "keywords": [
    "ping",
    "uptime",
    "monitor",
    "keep-alive",
    "free-tier",
    "backend",
    "server"
  ],
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "apis": {
    "classes": [
      {
        "name": "PingMe",
        "description": "The main class that handles the pinging logic.",
        "constructor": {
          "parameters": [
            {
              "name": "options",
              "type": "PingMeOptions",
              "description": "Configuration options for the PingMe instance",
              "required": true
            }
          ]
        },
        "methods": [
          {
            "name": "register",
            "description": "Register one or more endpoints to ping",
            "parameters": [
              {
                "name": "endpoints",
                "type": "string | string[]",
                "description": "One or more endpoint URLs to register",
                "required": true
              }
            ],
            "returns": "this",
            "returnDescription": "The PingMe instance for chaining"
          },
          {
            "name": "unregister",
            "description": "Unregister one or more endpoints",
            "parameters": [
              {
                "name": "endpoints",
                "type": "string | string[]",
                "description": "One or more endpoint URLs to unregister",
                "required": true
              }
            ],
            "returns": "this",
            "returnDescription": "The PingMe instance for chaining"
          },
          {
            "name": "start",
            "description": "Start the ping service",
            "parameters": [],
            "returns": "this",
            "returnDescription": "The PingMe instance for chaining"
          },
          {
            "name": "stop",
            "description": "Stop the ping service",
            "parameters": [],
            "returns": "this",
            "returnDescription": "The PingMe instance for chaining"
          },
          {
            "name": "setPingInterval",
            "description": "Change the ping interval",
            "parameters": [
              {
                "name": "interval",
                "type": "number",
                "description": "The new ping interval in milliseconds",
                "required": true
              }
            ],
            "returns": "this",
            "returnDescription": "The PingMe instance for chaining"
          },
          {
            "name": "getStatus",
            "description": "Get the current status of the ping service",
            "parameters": [],
            "returns": "PingMeStatus",
            "returnDescription": "The current status of the ping service"
          },
          {
            "name": "pingAll",
            "description": "Manually ping all registered endpoints immediately",
            "parameters": [],
            "returns": "Promise<Record<string, PingResult>>",
            "returnDescription": "A promise that resolves to an object mapping endpoint URLs to their ping results"
          },
          {
            "name": "ping",
            "description": "Manually ping a specific endpoint immediately",
            "parameters": [
              {
                "name": "endpoint",
                "type": "string",
                "description": "The endpoint URL to ping",
                "required": true
              }
            ],
            "returns": "Promise<PingResult>",
            "returnDescription": "A promise that resolves to the ping result"
          }
        ],
        "properties": [
          {
            "name": "apiKey",
            "type": "string",
            "description": "The API key used for authentication",
            "access": "private"
          },
          {
            "name": "pingInterval",
            "type": "number",
            "description": "The interval between pings in milliseconds",
            "access": "private"
          },
          {
            "name": "onSuccess",
            "type": "Function",
            "description": "Callback function called when a ping succeeds",
            "access": "private"
          },
          {
            "name": "onError",
            "type": "Function",
            "description": "Callback function called when a ping fails",
            "access": "private"
          },
          {
            "name": "endpoints",
            "type": "Set<string>",
            "description": "Set of registered endpoint URLs",
            "access": "private"
          },
          {
            "name": "intervalId",
            "type": "NodeJS.Timeout",
            "description": "ID of the interval timer",
            "access": "private"
          },
          {
            "name": "lastPingTimestamp",
            "type": "number",
            "description": "Timestamp of the last ping",
            "access": "private"
          },
          {
            "name": "lastPingResults",
            "type": "Record<string, PingResult>",
            "description": "Results of the last ping by endpoint",
            "access": "private"
          },
          {
            "name": "apiEndpoint",
            "type": "string",
            "description": "URL of the Ping-Me API endpoint",
            "access": "private"
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "pingMe",
        "description": "A simplified API for cases where you just want to ping a single URL",
        "parameters": [
          {
            "name": "options",
            "type": "PingMeOptions & { url: string }",
            "description": "Configuration options including the URL to ping",
            "required": true
          }
        ],
        "returns": "() => void",
        "returnDescription": "A function that stops the pinging when called"
      }
    ],
    "interfaces": [
      {
        "name": "PingMeOptions",
        "description": "Configuration options for the PingMe constructor",
        "properties": [
          {
            "name": "apiKey",
            "type": "string",
            "description": "Your Ping-Me API key",
            "required": true
          },
          {
            "name": "pingInterval",
            "type": "number",
            "description": "Ping interval in milliseconds (default: 5 minutes)",
            "required": false
          },
          {
            "name": "onSuccess",
            "type": "(endpoint: string, responseTime: number) => void",
            "description": "Function called when a ping succeeds",
            "required": false
          },
          {
            "name": "onError",
            "type": "(error: Error, endpoint: string) => void",
            "description": "Function called when a ping fails",
            "required": false
          },
          {
            "name": "autoStart",
            "type": "boolean",
            "description": "Whether to automatically start pinging (default: false)",
            "required": false
          }
        ]
      },
      {
        "name": "PingMeStatus",
        "description": "Status information for a PingMe instance",
        "properties": [
          {
            "name": "isActive",
            "type": "boolean",
            "description": "Whether the ping service is currently active",
            "required": true
          },
          {
            "name": "endpoints",
            "type": "string[]",
            "description": "The registered endpoints",
            "required": true
          },
          {
            "name": "pingInterval",
            "type": "number",
            "description": "The current ping interval in milliseconds",
            "required": true
          },
          {
            "name": "lastPingTimestamp",
            "type": "number",
            "description": "The timestamp of the last ping (if any)",
            "required": false
          },
          {
            "name": "lastPingResults",
            "type": "Record<string, PingResult>",
            "description": "The results of the last ping by endpoint",
            "required": true
          }
        ]
      },
      {
        "name": "PingResult",
        "description": "Result of a ping operation",
        "properties": [
          {
            "name": "success",
            "type": "boolean",
            "description": "Whether the ping was successful",
            "required": true
          },
          {
            "name": "responseTime",
            "type": "number",
            "description": "Response time in milliseconds (if successful)",
            "required": false
          },
          {
            "name": "error",
            "type": "string",
            "description": "Error message (if failed)",
            "required": false
          },
          {
            "name": "timestamp",
            "type": "number",
            "description": "Timestamp of when the ping was performed",
            "required": true
          }
        ]
      }
    ]
  },
  "usage": {
    "basic": {
      "title": "Basic Usage",
      "description": "Simple example of using the core package",
      "code": "import { PingMe } from '@ping-me/core';\n\nconst pingMe = new PingMe({\n  apiKey: 'your-api-key-here',\n});\n\npingMe.register([\n  'https://your-api.example.com',\n  'https://your-app.example.com',\n]);\n\npingMe.start();\n\n// Later, when your application is shutting down\npingMe.stop();"
    },
    "advancedExamples": [
      {
        "title": "Custom Ping Intervals Based on Time",
        "description": "Change ping frequency based on time of day",
        "code": "import { PingMe } from '@ping-me/core';\n\nconst pingMe = new PingMe({\n  apiKey: 'your-api-key-here',\n});\n\npingMe.register('https://api.example.com');\npingMe.start();\n\n// Set up a schedule to change ping intervals\nconst businessHoursInterval = 60000; // 1 minute\nconst offHoursInterval = 300000; // 5 minutes\n\nfunction updatePingInterval() {\n  const hour = new Date().getHours();\n  // Business hours: 9 AM to 5 PM\n  if (hour >= 9 && hour < 17) {\n    pingMe.setPingInterval(businessHoursInterval);\n  } else {\n    pingMe.setPingInterval(offHoursInterval);\n  }\n}\n\n// Update interval every hour\nsetInterval(updatePingInterval, 3600000);\n// Initial update\nupdatePingInterval();"
      },
      {
        "title": "Custom Error Handling and Retries",
        "description": "Implement custom error handling with retry logic",
        "code": "import { PingMe } from '@ping-me/core';\n\n// Keep track of consecutive failures\nconst failureCount = {};\nconst MAX_FAILURES = 3;\n\nconst pingMe = new PingMe({\n  apiKey: 'your-api-key-here',\n  onSuccess: (endpoint) => {\n    // Reset failure count on success\n    failureCount[endpoint] = 0;\n  },\n  onError: async (error, endpoint) => {\n    // Increment failure count\n    failureCount[endpoint] = (failureCount[endpoint] || 0) + 1;\n    \n    console.error(`Failed to ping ${endpoint}: ${error.message}`);\n    \n    // If we've failed too many times, take action\n    if (failureCount[endpoint] >= MAX_FAILURES) {\n      console.error(`${endpoint} has failed ${failureCount[endpoint]} times in a row. Taking action...`);\n      \n      // Example: Send a notification\n      await sendNotification(`${endpoint} is down: ${error.message}`);\n      \n      // Example: Try an immediate retry\n      try {\n        console.log(`Attempting immediate retry for ${endpoint}...`);\n        const result = await pingMe.ping(endpoint);\n        if (result.success) {\n          console.log(`Retry succeeded for ${endpoint}`);\n          failureCount[endpoint] = 0;\n        }\n      } catch (retryError) {\n        console.error(`Retry also failed for ${endpoint}: ${retryError.message}`);\n      }\n    }\n  }\n});\n\npingMe.register(['https://api.example.com']);\npingMe.start();\n\nasync function sendNotification(message) {\n  // Implement your notification logic here\n  console.log(`NOTIFICATION: ${message}`);\n}"
      },
      {
        "title": "Using with Environment Variables",
        "description": "Load configuration from environment variables",
        "code": "import { PingMe } from '@ping-me/core';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\nconst API_KEY = process.env.PING_ME_API_KEY;\nif (!API_KEY) {\n  throw new Error('PING_ME_API_KEY environment variable is required');\n}\n\n// Parse comma-separated list of endpoints\nconst endpointsStr = process.env.PING_ME_ENDPOINTS || '';\nconst endpoints = endpointsStr.split(',').filter(url => url.trim());\n\nif (endpoints.length === 0) {\n  throw new Error('No endpoints specified in PING_ME_ENDPOINTS');\n}\n\n// Parse ping interval (default to 5 minutes)\nconst pingInterval = parseInt(process.env.PING_ME_INTERVAL || '300000', 10);\n\nconst pingMe = new PingMe({\n  apiKey: API_KEY,\n  pingInterval,\n  onError: (error, endpoint) => {\n    console.error(`Failed to ping ${endpoint}: ${error.message}`);\n  }\n});\n\npingMe.register(endpoints);\npingMe.start();\n\n// Handle process shutdown\nprocess.on('SIGINT', () => {\n  console.log('Stopping ping service...');\n  pingMe.stop();\n  process.exit(0);\n});"
      },
      {
        "title": "Handling Different Response Status Codes",
        "description": "Advanced response handling based on status codes",
        "code": "import { PingMe } from '@ping-me/core';\nimport fetch from 'node-fetch';\n\nconst pingMe = new PingMe({\n  apiKey: 'your-api-key-here',\n});\n\n// Start regular pinging\npingMe.register(['https://api.example.com']);\npingMe.start();\n\n// Custom ping function that checks for specific status codes\nasync function customPing(url) {\n  try {\n    const startTime = Date.now();\n    const response = await fetch(url);\n    const responseTime = Date.now() - startTime;\n    \n    if (response.status >= 200 && response.status < 300) {\n      console.log(`✅ ${url} responded with ${response.status} in ${responseTime}ms`);\n      return;\n    }\n    \n    if (response.status >= 300 && response.status < 400) {\n      console.warn(`⚠️ ${url} returned a redirect (${response.status}) in ${responseTime}ms`);\n      return;\n    }\n    \n    if (response.status === 401 || response.status === 403) {\n      console.error(`🔒 ${url} returned authentication error (${response.status}) in ${responseTime}ms`);\n      // Maybe credentials need to be updated\n      await sendAuthAlert(url, response.status);\n      return;\n    }\n    \n    if (response.status >= 500) {\n      console.error(`🚨 ${url} returned server error (${response.status}) in ${responseTime}ms`);\n      await sendServerErrorAlert(url, response.status);\n      return;\n    }\n    \n    console.warn(`❓ ${url} returned unexpected status (${response.status}) in ${responseTime}ms`);\n  } catch (error) {\n    console.error(`❌ Failed to ping ${url}: ${error.message}`);\n    await sendConnectionErrorAlert(url, error.message);\n  }\n}\n\n// Run custom ping check every 10 minutes\nsetInterval(() => {\n  pingMe.getStatus().endpoints.forEach(customPing);\n}, 10 * 60 * 1000);\n\nasync function sendAuthAlert(url, status) {\n  // Implement authentication alert\n}\n\nasync function sendServerErrorAlert(url, status) {\n  // Implement server error alert\n}\n\nasync function sendConnectionErrorAlert(url, error) {\n  // Implement connection error alert\n}"
      }
    ]
  },
  "troubleshooting": {
    "common": [
      {
        "issue": "API Key Issues",
        "solutions": [
          "Make sure your API key is valid and correctly formatted",
          "Check that your API key has the necessary permissions",
          "Verify that your account is active and in good standing",
          "Try generating a new API key from the dashboard"
        ]
      },
      {
        "issue": "Connection Issues",
        "solutions": [
          "Check that the endpoints are accessible from the environment where ping-me is running",
          "Verify that there are no network restrictions or firewalls blocking the connections",
          "Check if the endpoints require authentication or special headers",
          "Try pinging the endpoints manually to confirm they're reachable"
        ]
      },
      {
        "issue": "High CPU or Memory Usage",
        "solutions": [
          "Reduce the number of endpoints being monitored",
          "Increase the ping interval to reduce frequency",
          "Simplify any custom logic in the onSuccess and onError handlers",
          "Check for memory leaks in your application"
        ]
      }
    ],
    "debugging": {
      "title": "Detailed Logging",
      "description": "Implement detailed logging to debug issues",
      "code": "import { PingMe } from '@ping-me/core';\nimport fs from 'fs';\n\n// Set up a log file\nconst logStream = fs.createWriteStream('ping-me.log', { flags: 'a' });\n\nfunction log(message) {\n  const timestamp = new Date().toISOString();\n  const logMessage = `[${timestamp}] ${message}\\n`;\n  logStream.write(logMessage);\n  console.log(message);\n}\n\nconst pingMe = new PingMe({\n  apiKey: 'your-api-key-here',\n  onSuccess: (endpoint, responseTime) => {\n    log(`Success: ${endpoint} responded in ${responseTime}ms`);\n  },\n  onError: (error, endpoint) => {\n    log(`Error: Failed to ping ${endpoint}: ${error.message}`);\n  }\n});\n\npingMe.register(['https://api.example.com']);\n\nlog('Starting ping service...');\npingMe.start();\n\n// Log status periodically\nsetInterval(() => {\n  const status = pingMe.getStatus();\n  log(`Status: active=${status.isActive}, endpoints=${status.endpoints.length}, interval=${status.pingInterval}ms`);\n  \n  for (const [endpoint, result] of Object.entries(status.lastPingResults)) {\n    if (result.success) {\n      log(`Last ping for ${endpoint}: success, ${result.responseTime}ms, at ${new Date(result.timestamp).toISOString()}`);\n    } else {\n      log(`Last ping for ${endpoint}: failed, \"${result.error}\", at ${new Date(result.timestamp).toISOString()}`);\n    }\n  }\n}, 60000); // Log every minute"
    }
  },
  "bestPractices": {
    "security": [
      "Never hardcode your API key in your code. Use environment variables or a secure configuration management system.",
      "Only give the ping service access to the endpoints it needs to monitor.",
      "Always use HTTPS URLs for your endpoints to ensure secure communication."
    ],
    "performance": [
      "Choose a ping interval that balances keeping your service alive with minimizing unnecessary network traffic.",
      "Consider implementing logic to ping only during certain hours or when your service is likely to be idle.",
      "If monitoring many endpoints, consider staggering the pings to avoid network congestion."
    ],
    "reliability": [
      "Implement robust error handling to ensure the ping service continues to function even if some pings fail.",
      "Always call stop() when your application is shutting down to ensure clean termination.",
      "Set up a secondary monitoring system to ensure your ping service itself is running correctly."
    ]
  }
} 